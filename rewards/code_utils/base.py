BASE_IMPORTS = """from itertools import accumulate, chain, combinations, count, permutations, product, groupby, islice, repeat
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase
from collections import defaultdict, deque, Counter
from bisect import bisect, bisect_left, bisect_right, insort
from operator import itemgetter, sub, xor, or_
from typing import List, Tuple, Dict, Set, Optional, Union, Any, Callable, Iterable, Iterator, Generator, Deque
import copy
import string
import math
import datetime
from time import time
import numpy as np
import pandas as pd

from random import randrange, shuffle
from functools import reduce, cache, lru_cache, cmp_to_key, reduce
from math import floor, log2, log10, sqrt, comb, gcd, ceil, inf, isqrt, factorial, atan2, pi
from heapq import heappush, heappop, heapify, merge, nlargest, nsmallest, heapreplace
from os.path import commonprefix
from re import search as re_search  # Assuming 're' refers to a regex search
import collections
import bisect
import heapq
import functools
import random
import itertools
import operator
import re
from math import log, prod  # 'log' and 'prod' are functions in the math module
from collections import deque, defaultdict, Counter, OrderedDict
from itertools import accumulate, permutations, combinations, product, groupby, islice, chain, repeat, zip_longest, cycle, pairwise
from functools import lru_cache, reduce, partial
from operator import iand
import io, os
import sys
"""

BASE_LEETCODE_IMPORTS = """
# Leetcode specials
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def is_same_list(l1: Optional[ListNode], l2: Optional[ListNode]) -> bool:
    while l1 and l2:
        if l1.val != l2.val:
            return False
        l1 = l1.next
        l2 = l2.next
    return l1 is None and l2 is None

def list_node(values: List[Any]) -> Optional[ListNode]:
    dummy = ListNode(0)
    current = dummy
    for value in values:
        current.next = ListNode(value)
        current = current.next
    return dummy.next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def tree_node(values: List[Any]) -> Optional[TreeNode]:
    if not values:
        return None

    root = TreeNode(values[0])
    queue = deque([root])
    i = 1

    while queue and i < len(values):
        node = queue.popleft()

        if values[i] is not None:
            node.left = TreeNode(values[i])
            queue.append(node.left)
        i += 1

        if i < len(values) and values[i] is not None:
            node.right = TreeNode(values[i])
            queue.append(node.right)
        i += 1

    return root

def is_same_tree(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
    if not p and not q:
        return True
    if not p or not q:
        return False
    return p.val == q.val and is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)
"""
